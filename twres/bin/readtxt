#!/bin/bash

terminal_size=$(stty size)
terminal_height=$(echo "$terminal_size" | cut -d ' ' -f 1)
terminal_width=$(echo "$terminal_size" | cut -d ' ' -f 2)

readonly VIEW_HEIGHT=$((terminal_height - 4))
readonly CONTENT_WIDTH=$((terminal_width - 6))

stty_orig="$(stty -g)"
trap 'stty "$stty_orig"; printf "\033c"' EXIT INT TERM

if [ -z "$1" ]; then
    printf "\033c"
    echo "Usage: $0 <filename>"
    echo "This script reads a file line-by-line (wrapped segments) using 'Vol+' (up) and 'Vol-' (down)."
    exit 1
fi

FILE="$1"

if [ ! -f "$FILE" ]; then
    printf "\033c"
    echo "Error: File '$FILE' not found."
    exit 1
fi

lines=()
while IFS= read -r line; do
    lines+=("$line")
done < "$FILE"

TOTAL_LINES=${#lines[@]} 

WRAPPED_LINES=()
TOTAL_WRAPPED_LINES=0

generate_wrapped_lines() {
    WRAPPED_LINES=()
    local original_line_number=0

    for line_content in "${lines[@]}"; do
        original_line_number=$((original_line_number + 1))
        local content_length=${#line_content}
        local segment_start=0
        local is_first_segment=true

        if [ "$content_length" -eq 0 ]; then
            WRAPPED_LINES+=("$original_line_number::")
            continue
        fi

        while [ "$segment_start" -lt "$content_length" ]; do
            local segment="${line_content:$segment_start:$CONTENT_WIDTH}"
            
            if "$is_first_segment"; then
                WRAPPED_LINES+=("$original_line_number::$segment")
                is_first_segment=false
            else
                WRAPPED_LINES+=("0::$segment")
            fi

            segment_start=$((segment_start + CONTENT_WIDTH))
        done
    done

    TOTAL_WRAPPED_LINES=${#WRAPPED_LINES[@]}
}

generate_wrapped_lines

if [ "$TOTAL_WRAPPED_LINES" -eq 0 ]; then
    printf "\033c"
    echo "Error: File '$FILE' is empty or content width is too small."
    exit 1
fi

CURRENT_INDEX=0

display_page() {
	printf "\033c"

    local start_index=$CURRENT_INDEX
    local total_lines_to_show=$TOTAL_WRAPPED_LINES
    
    local LINES_TO_DISPLAY=$((total_lines_to_show - start_index))
    if [ "$LINES_TO_DISPLAY" -gt "$VIEW_HEIGHT" ]; then
        LINES_TO_DISPLAY=$VIEW_HEIGHT
    fi
    local END_INDEX=$((start_index + LINES_TO_DISPLAY - 1))
    
    if [ "$total_lines_to_show" -lt "$VIEW_HEIGHT" ]; then
        start_index=0
        END_INDEX=$((total_lines_to_show - 1))
    fi

    local i_start=$start_index
    local original_start_line="?"
    while [ "$i_start" -ge 0 ]; do
        local segment_i="${WRAPPED_LINES[i_start]}"
        local original_num="${segment_i%%::*}"
        if [ "$original_num" -ne 0 ]; then
            original_start_line="$original_num"
            break
        fi
        i_start=$((i_start - 1))
    done

    local i_end=$END_INDEX
    local original_end_line="?"
    while [ "$i_end" -ge 0 ]; do
        local segment_i="${WRAPPED_LINES[i_end]}"
        local original_num="${segment_i%%::*}"
        if [ "$original_num" -ne 0 ]; then
            original_end_line="$original_num"
            break
        fi
        i_end=$((i_end - 1))
    done

    echo " [ Current Line $original_start_line - $original_end_line of $TOTAL_LINES ]"

    for ((i=start_index; i<=END_INDEX; i++)); do
        local segment="${WRAPPED_LINES[i]}"
        
        local original_line_num="${segment%%::*}"
        local content="${segment#*::}"
        
        if [ "$original_line_num" != "0" ]; then
            printf "%-4s: %s\n" "$original_line_num" "$content"
        else
            printf "      %s\n" "$content"
        fi
    done

    LINES_PRINTED=$((END_INDEX - start_index + 1))
    for (( j = LINES_PRINTED; j < VIEW_HEIGHT; j++ )); do
        echo
    done
    
    echo "   Vol+ (down), Vol- (up), Vol- + Power (quit)   "
}

done_read () {
	echo "Quit?"
    echo "Press [Vol+] Yes / [Vol-] No"
    
    local stty_orig="$(stty -g)"
    
    while true; do
        stty -echo -icanon
        read -n 1 menu_key
        stty "$stty_orig"
        
        case "$menu_key" in
            k)
                echo -e "\n--- CONFIRMED: Starting Wipe ---\n"
                break
                ;;
            j)
                echo -e "\n--- CANCELED: Returning to Menu ---\n"
                sleep 2
                return 0
                ;;
            *)
                stty -echo -icanon 
                ;;
        esac
    done
    
    bash /twres/bin/main

    echo "Selective Factory Reset Complete."
    sleep 2
}

while true; do
    display_page

    read -p " " -n 1 COMMAND
    
    if [ ! -z "$COMMAND" ]; then
        echo
    fi

    case "$COMMAND" in
        k)
            if [ "$CURRENT_INDEX" -lt $((TOTAL_WRAPPED_LINES - 1)) ]; then
                CURRENT_INDEX=$((CURRENT_INDEX + 1))
            else
                echo -e "\n[INFO] Already at the end of the content."
                sleep 0.5
            fi
            ;;
        j)
            if [ "$CURRENT_INDEX" -gt 0 ]; then
                CURRENT_INDEX=$((CURRENT_INDEX - 1))
            else
                echo -e "\n[INFO] Already at the beginning of the content."
                sleep 0.5
            fi
            ;;
        l)
            done_read
            ;;
        *)
            if [ ! -z "$COMMAND" ]; then
                 echo -e "\n[ERROR] Invalid command: '$COMMAND'. Please use 'vol+', 'vol-', or 'vol- + power'."
                 sleep 0.5
            fi
            ;;
    esac
done
